// Code generated by gowsdl DO NOT EDIT.

package accessrules

import (
	"context"
	"encoding/xml"
	"time"

	"github.com/videonext/onvif/soap"
)

// against "unused imports"
var _ time.Time
var _ xml.Name

type Capabilities ServiceCapabilities

type GetServiceCapabilities struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetServiceCapabilities"`
}

type GetServiceCapabilitiesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetServiceCapabilitiesResponse"`

	// The capability response message contains the requested access rules
	// service capabilities using a hierarchical XML capability structure.
	//
	Capabilities *ServiceCapabilities `xml:"Capabilities,omitempty"`
}

type GetAccessProfileInfo struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfileInfo"`

	// Tokens of AccessProfileInfo items to get.
	Token []*ReferenceToken `xml:"Token,omitempty"`
}

type GetAccessProfileInfoResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfileInfoResponse"`

	// List of AccessProfileInfo items.
	AccessProfileInfo []*AccessProfileInfo `xml:"AccessProfileInfo,omitempty"`
}

type GetAccessProfileInfoList struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfileInfoList"`

	// Maximum number of entries to return. If not specified, less than one
	// or higher than what the device supports, the number of items is determined by the
	// device.
	//
	Limit int32 `xml:"Limit,omitempty"`

	// Start returning entries from this start reference. If not specified,
	// entries shall start from the beginning of the dataset.
	//
	StartReference string `xml:"StartReference,omitempty"`
}

type GetAccessProfileInfoListResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfileInfoListResponse"`

	// StartReference to use in next call to get the following items. If
	// absent, no more items to get.
	//
	NextStartReference string `xml:"NextStartReference,omitempty"`

	// List of AccessProfileInfo items.
	AccessProfileInfo []*AccessProfileInfo `xml:"AccessProfileInfo,omitempty"`
}

type GetAccessProfiles struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfiles"`

	// Tokens of AccessProfile items to get.
	Token []*ReferenceToken `xml:"Token,omitempty"`
}

type GetAccessProfilesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfilesResponse"`

	// List of Access Profile items.
	AccessProfile []*AccessProfile `xml:"AccessProfile,omitempty"`
}

type GetAccessProfileList struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfileList"`

	// Maximum number of entries to return. If not specified, less than one
	// or higher than what the device supports, the number of items is determined by the
	// device.
	//
	Limit int32 `xml:"Limit,omitempty"`

	// Start returning entries from this start reference. If not specified,
	// entries shall start from the beginning of the dataset.
	//
	StartReference string `xml:"StartReference,omitempty"`
}

type GetAccessProfileListResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl GetAccessProfileListResponse"`

	// StartReference to use in next call to get the following items. If
	// absent, no more items to get.
	//
	NextStartReference string `xml:"NextStartReference,omitempty"`

	// List of Access Profile items.
	AccessProfile []*AccessProfile `xml:"AccessProfile,omitempty"`
}

type CreateAccessProfile struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl CreateAccessProfile"`

	// The AccessProfile to create.
	AccessProfile *AccessProfile `xml:"AccessProfile,omitempty"`
}

type CreateAccessProfileResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl CreateAccessProfileResponse"`

	// The Token of created AccessProfile.
	Token *ReferenceToken `xml:"Token,omitempty"`
}

type ModifyAccessProfile struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl ModifyAccessProfile"`

	// The details of Access Profile
	AccessProfile *AccessProfile `xml:"AccessProfile,omitempty"`
}

type ModifyAccessProfileResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl ModifyAccessProfileResponse"`
}

type SetAccessProfile struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl SetAccessProfile"`

	// The AccessProfile item to create or modify
	AccessProfile *AccessProfile `xml:"AccessProfile,omitempty"`
}

type SetAccessProfileResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl SetAccessProfileResponse"`
}

type DeleteAccessProfile struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl DeleteAccessProfile"`

	// The token of the access profile to delete.
	Token *ReferenceToken `xml:"Token,omitempty"`
}

type DeleteAccessProfileResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl DeleteAccessProfileResponse"`
}

type ServiceCapabilities struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/accessrules/wsdl Capabilities"`

	//
	// The maximum number of entries returned by a single Get<Entity>List or Get<Entity>
	// request. The device shall never return more than this number of entities in a single
	// response.
	//

	MaxLimit uint32 `xml:"MaxLimit,attr,omitempty"`

	//
	// Indicates the maximum number of access profiles supported by the device.
	//

	MaxAccessProfiles uint32 `xml:"MaxAccessProfiles,attr,omitempty"`

	//
	// Indicates the maximum number of access policies per access profile supported by the device.
	//

	MaxAccessPoliciesPerAccessProfile uint32 `xml:"MaxAccessPoliciesPerAccessProfile,attr,omitempty"`

	//
	// Indicates whether or not several access policies can refer to the same access point in an
	// access profile.
	//

	MultipleSchedulesPerAccessPointSupported bool `xml:"MultipleSchedulesPerAccessPointSupported,attr,omitempty"`

	//
	// Indicates that the client is allowed to supply the token when creating access profiles. To
	// enable the use of the command SetAccessProfile, the value must be set to true.
	//

	ClientSuppliedTokenSupported bool `xml:"ClientSuppliedTokenSupported,attr,omitempty"`
}

type AccessPolicy struct {

	// Reference to the schedule used by the access policy.
	ScheduleToken *ReferenceToken `xml:"ScheduleToken,omitempty"`

	//
	// Reference to the entity used by the rule engine, the entity type may be specified by the
	// optional EntityType field explained below but is typically an access point.
	//
	Entity *ReferenceToken `xml:"Entity,omitempty"`

	//
	// Optional entity type; if missing, an access point type as defined by the ONVIF Access
	// Control Service Specification should be assumed. This can also be represented by the
	// QName value	“tac:AccessPoint” where tac is the namespace of ONVIF Access Control
	// Service Specification. This field is provided for future extensions; it will allow an
	// access policy being	extended to cover entity types other than access points as well.
	//
	EntityType *QName `xml:"EntityType,omitempty"`

	Extension *AccessPolicyExtension `xml:"Extension,omitempty"`
}

type AccessPolicyExtension struct {
}

type AccessProfileInfo struct {
	*DataEntity

	// A user readable name. It shall be up to 64 characters.
	//
	Name *Name `xml:"Name,omitempty"`

	// User readable description for the access profile. It shall be up
	// to 1024 characters.
	//
	Description *Description `xml:"Description,omitempty"`
}

type AccessProfile struct {
	*AccessProfileInfo

	// A list of access policy structures, where each access policy
	// defines during which schedule an access point can be accessed.
	//
	AccessPolicy []*AccessPolicy `xml:"AccessPolicy,omitempty"`

	Extension *AccessProfileExtension `xml:"Extension,omitempty"`
}

type AccessProfileExtension struct {
}

// Type used to reference logical and physical entities.

type ReferenceToken string

// Type used for names of logical and physical entities.

type Name string

// Description is optional and the maximum length is device specific.
// If the length is more than maximum length, it is silently chopped to the maximum length
// supported by the device/service (which may be 0).
//

type Description string

// Type used to represent the numbers from 1 ,2 , 3,...

type PositiveInteger uint32

type DataEntity struct {

	// A service-unique identifier of the item.

	Token *ReferenceToken `xml:"token,attr,omitempty"`
}

type Attribute struct {

	// Name of attribute. Key names starting with "ONVIF" (any case) are reserved for ONVIF
	// use.
	//

	Name string `xml:"Name,attr,omitempty"`

	// Value of attribute

	Value string `xml:"Value,attr,omitempty"`
}

type AccessRulesPort interface {

	/* This operation returns the capabilities of the access rules service.
	 */
	GetServiceCapabilities(request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error)

	GetServiceCapabilitiesContext(ctx context.Context, request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error)

	/*
		This operation requests a list of AccessProfileInfo items matching the given tokens. The device shall
		ignore tokens it cannot resolve and shall return an empty list if there are no items matching the
		specified tokens. The device shall not return a fault in this case.
		If the number of requested items is greater than MaxLimit, a TooManyItems fault shall be returned.
	*/
	GetAccessProfileInfo(request *GetAccessProfileInfo) (*GetAccessProfileInfoResponse, error)

	GetAccessProfileInfoContext(ctx context.Context, request *GetAccessProfileInfo) (*GetAccessProfileInfoResponse, error)

	/*
		This operation requests a list of all of AccessProfileInfo items provided by the device.
		A call to this method shall return a StartReference when not all data is returned and more data is
		available. The reference shall be valid for retrieving the next set of data.
		The number of items returned shall not be greater than the Limit parameter.
	*/
	GetAccessProfileInfoList(request *GetAccessProfileInfoList) (*GetAccessProfileInfoListResponse, error)

	GetAccessProfileInfoListContext(ctx context.Context, request *GetAccessProfileInfoList) (*GetAccessProfileInfoListResponse, error)

	/*
		This operation returns the specified access profile item matching the given tokens.
		The device shall ignore tokens it cannot resolve and shall return an empty list if there are no items
		matching specified tokens. The device shall not return a fault in this case.
		If the number of requested items is greater than MaxLimit, a TooManyItems fault shall be returned.
	*/
	GetAccessProfiles(request *GetAccessProfiles) (*GetAccessProfilesResponse, error)

	GetAccessProfilesContext(ctx context.Context, request *GetAccessProfiles) (*GetAccessProfilesResponse, error)

	/*
		This operation requests a list of all of access profile items provided by the device.
		A call to this method shall return a StartReference when not all data is returned and more data is
		available. The reference shall be valid for retrieving the next set of data.
		The number of items returned shall not be greater than the Limit parameter.
	*/
	GetAccessProfileList(request *GetAccessProfileList) (*GetAccessProfileListResponse, error)

	GetAccessProfileListContext(ctx context.Context, request *GetAccessProfileList) (*GetAccessProfileListResponse, error)

	/*
		This operation creates the specified access profile in the device. The token field of the access profile shall be
		empty, the service shall allocate a token for the access profile. The allocated token shall be returned
		in the response. If the client sends any value in the token field, the device shall return InvalidArgVal
		as generic fault code.
		In an access profile, if several access policies specifying different schedules for the same access
		point will result in a union of the schedules.
	*/
	CreateAccessProfile(request *CreateAccessProfile) (*CreateAccessProfileResponse, error)

	CreateAccessProfileContext(ctx context.Context, request *CreateAccessProfile) (*CreateAccessProfileResponse, error)

	/*
		This operation will modify the access profile for the specified access profile token. The token of the
		access profile to modify is specified in the token field of the AccessProile structure and shall not
		be empty. All other fields in the structure shall overwrite the fields in the specified access profile.
		If several access policies specifying different schedules for the same access point will result in a
		union of the schedules.
		If the device could not store the access profile information then a fault will be generated.
	*/
	ModifyAccessProfile(request *ModifyAccessProfile) (*ModifyAccessProfileResponse, error)

	ModifyAccessProfileContext(ctx context.Context, request *ModifyAccessProfile) (*ModifyAccessProfileResponse, error)

	/*
		This operation will synchronize an access profile in a client with the device.
		If an access profile with the specified token does not exist in the device, the access profile is
		created. If an access profile with the specified token exists, then the access profile is modified.
		A call to this method takes an access profile structure as input parameter. The token field of the
		access profile must not be empty.
		A device that signals support for the ClientSuppliedTokenSupported capability shall implement this command.
	*/
	SetAccessProfile(request *SetAccessProfile) (*SetAccessProfileResponse, error)

	SetAccessProfileContext(ctx context.Context, request *SetAccessProfile) (*SetAccessProfileResponse, error)

	/*
		This operation will delete the specified access profile.
		If the access profile is deleted, all access policies associated to the access profile will also be
		deleted.
		If it is associated with one or more entities some devices may not be able to delete the access profile,
		and consequently a ReferenceInUse fault shall be generated.
	*/
	DeleteAccessProfile(request *DeleteAccessProfile) (*DeleteAccessProfileResponse, error)

	DeleteAccessProfileContext(ctx context.Context, request *DeleteAccessProfile) (*DeleteAccessProfileResponse, error)
}

type accessRulesPort struct {
	client *soap.Client
	xaddr  string
}

func NewAccessRulesPort(client *soap.Client, xaddr string) AccessRulesPort {
	return &accessRulesPort{
		client: client,
		xaddr:  xaddr,
	}
}

func (service *accessRulesPort) GetServiceCapabilitiesContext(ctx context.Context, request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error) {
	response := new(GetServiceCapabilitiesResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) GetServiceCapabilities(request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error) {
	return service.GetServiceCapabilitiesContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) GetAccessProfileInfoContext(ctx context.Context, request *GetAccessProfileInfo) (*GetAccessProfileInfoResponse, error) {
	response := new(GetAccessProfileInfoResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) GetAccessProfileInfo(request *GetAccessProfileInfo) (*GetAccessProfileInfoResponse, error) {
	return service.GetAccessProfileInfoContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) GetAccessProfileInfoListContext(ctx context.Context, request *GetAccessProfileInfoList) (*GetAccessProfileInfoListResponse, error) {
	response := new(GetAccessProfileInfoListResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) GetAccessProfileInfoList(request *GetAccessProfileInfoList) (*GetAccessProfileInfoListResponse, error) {
	return service.GetAccessProfileInfoListContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) GetAccessProfilesContext(ctx context.Context, request *GetAccessProfiles) (*GetAccessProfilesResponse, error) {
	response := new(GetAccessProfilesResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) GetAccessProfiles(request *GetAccessProfiles) (*GetAccessProfilesResponse, error) {
	return service.GetAccessProfilesContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) GetAccessProfileListContext(ctx context.Context, request *GetAccessProfileList) (*GetAccessProfileListResponse, error) {
	response := new(GetAccessProfileListResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) GetAccessProfileList(request *GetAccessProfileList) (*GetAccessProfileListResponse, error) {
	return service.GetAccessProfileListContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) CreateAccessProfileContext(ctx context.Context, request *CreateAccessProfile) (*CreateAccessProfileResponse, error) {
	response := new(CreateAccessProfileResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) CreateAccessProfile(request *CreateAccessProfile) (*CreateAccessProfileResponse, error) {
	return service.CreateAccessProfileContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) ModifyAccessProfileContext(ctx context.Context, request *ModifyAccessProfile) (*ModifyAccessProfileResponse, error) {
	response := new(ModifyAccessProfileResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) ModifyAccessProfile(request *ModifyAccessProfile) (*ModifyAccessProfileResponse, error) {
	return service.ModifyAccessProfileContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) SetAccessProfileContext(ctx context.Context, request *SetAccessProfile) (*SetAccessProfileResponse, error) {
	response := new(SetAccessProfileResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) SetAccessProfile(request *SetAccessProfile) (*SetAccessProfileResponse, error) {
	return service.SetAccessProfileContext(
		context.Background(),
		request,
	)
}

func (service *accessRulesPort) DeleteAccessProfileContext(ctx context.Context, request *DeleteAccessProfile) (*DeleteAccessProfileResponse, error) {
	response := new(DeleteAccessProfileResponse)
	err := service.client.CallContext(ctx, service.xaddr, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *accessRulesPort) DeleteAccessProfile(request *DeleteAccessProfile) (*DeleteAccessProfileResponse, error) {
	return service.DeleteAccessProfileContext(
		context.Background(),
		request,
	)
}
